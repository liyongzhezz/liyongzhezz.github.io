---
title: redis基础
date: 2020-10-11 15:40:54
tags:
- Redis
categories:
- 数据库
- Redis
description: redis基础概念
cover: https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2451921005,155161323&fm=26&gp=0.jpg
---



## Redis和memcache比较

redis和memcache都是内存数据库，在缓存上应用都比较多，它们在以下的方面会有一些区别：



### 线程模型

memcache采用多线程模型，基于IO多路复用技术，主线程接收到请求后分配给子线程进行处理。

- **优点：**
  - 这样当某个请求耗时较长，不会影响到其他的请求。
- **缺点：**
  - CPU多线程切换带来性能损耗；
  - 多线程访问共享资源必定加锁，导致性能损耗；



redis采用IO多路复用技术，但处理请求是单线程模型，接收请求到处理请求都在一个线程中完成。

- **优点：**
  - 减少了CPU上下文切换的损耗；
  - 没有多线程访问共享资源的加锁竞争；
- **缺点：**
  - 一个请求处理时间较长，会影响后面的请求；
  - 无法利用cpu多核特性；



> redis使用应避免执行复杂的耗时操作，如果key的数据量较大，则可能memcache的性能会更好一些。



### 数据结构

memcache仅支持`string`类型的操作，且value的大小必须在1MB以下，过期时间不能超过30天。



redis支持多种数据类型，例如：`string`、`set`、`list`、`hash`等。





### 淘汰策略

memcahched必须设置实例的内存上限，达到上限后会触发LRU淘汰机制，不常使用的冷数据会被优先淘汰。



redis没有设置内存上限，只要内存够用就会使用最大的内存，同时支持多种淘汰策略：

- volatile-lru：从过期key中按LRU机制淘汰
- allkeys-lru：在所有key中按LRU机制淘汰
- volatile-random：在过期key中随机淘汰key
- allkeys-random：在所有key中随机淘汰key
- volatile-ttl：优先淘汰最近要过期的key
- volatile-lfu：在所有key中按LFU机制淘汰
- allkeys-lfu：在过期key中按LFU机制淘汰



### 管道与事务

Redis还支持管道功能，客户端一次性打包发送多条命令到服务端，服务端依次处理客户端发来的命令。这样可以减少来回往来的网络IO次数，提供高访问性能。

另外它还支持事务，这里所说的事务并不是MySQL那样严格的事务模型，这种事务模型是Redis特有的。

一般事务会配合管道一块使用，客户端一次性打包发送多条命令到服务端，并且标识这些命令必须严格按顺序执行，不能被其他客户端打断。同时执行事务之前，客户端可以告诉服务端某个key稍后会进行相关操作，如果这个客户端在操作这个key之前，有其他客户端对这个key进行更改，那么当前客户端在执行这些命令时会放弃整个事务操作，保证一致性。



### 持久化

memcache不支持持久化数据，如果服务器宕机，则会丢失全部的数据；



redis支持aof和rdb两种方式的持久化数据的方式，可以避免宕机带来的数据丢失的问题；



### 高可用

memcached没有主从复制的架构，仅支持单机部署。



redis支持主从复制架构，两个节点组成主从架构，从可以实时同步主的数据，提高整个Redis服务的可用性。同时Redis还提供了哨兵节点，在主节点宕机时，主动把从节点提升为主节点，继续提供服务。主从两个节点还可以提供读写分离功能，进一步提高程序访问的性能。



### 集群

Memcached的集群化是在客户端采用一致性哈希算法向指定节点发送数据，当一个节点宕机时，其他节点会分担这个节点的请求。



Redis集群化采用的是每个节点维护一部分虚拟槽位，通过key的哈希计算，将key映射到具体的虚拟槽位上，这个槽位再映射到具体的Redis节点。同时每个Redis节点都包含至少一个从节点，组成主从架构，进一步提高每个节点的高可用能力。当增加或下线节点时，需要手动触发数据迁移，重新进行哈希槽位映射。



### 怎么选择

如果你的业务需要各种数据结构给予支撑，同时要求数据的高可用保障，那么选择Redis是比较合适的。

如果你的业务非常简单，只是简单的set/get，并且对于内存使用并不高，那么使用简单的Memcached足够。