---
title: 提升程序性能的技巧
date: 2020-09-05 20:14:40
tags:
- Python
categories:
- Python
- 优化
description: 几个技巧提升python代码运行性能
cover: https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1599318216101&di=957e0ba38c3e30a252eab7b069fbf3bc&imgtype=0&src=http%3A%2F%2Fshp.qpic.cn%2Fqqvideo_ori%2F0%2Fg0857o2eaih_496_280%2F0
---



# 重要！代码优化原则

1. 不要过早开始优化，代码优化的前提是代码能够正常工作；
2. 优化是有代价的；
3. 不优化无关紧要的部分，如果对代码每一部分都进行优化，就以为这代码会变得难以理解，专注在运行慢的地方进行优化即可；



<br>



# 避免全局变量

在python中，全局变量和局部变量的实现方式不同，定义在全局范围内的代码运行速度会比定义在函数中的慢不少，例如：

```python
import math

size = 10000
for x in range(size):
    for y in range(size):
        z = math.sqrt(x) + math.sqrt(y)
```



执行上述代码花费时间`39s`左右：

![](1.png)



对上面的代码做出如下的优化，即可有一定性能提升：

```python
import math

def main():  # 定义到函数中，以减少全部变量使用
    size = 10000
    for x in range(size):
        for y in range(size):
            z = math.sqrt(x) + math.sqrt(y)

main()
```



执行上述代码花费大约`36s`左右：

![](2.png)



<br>



# 避免模块和属性访问

每次使用`.（属性访问操作符时）`会触发特定的方法，如`__getattribute__()`和`__getattr__()`，这些方法会进行字典操作，因此会带来额外的时间开销。



例如：

```python
import math

def computeSqrt(size: int):
    result = []
    for i in range(size):
        result.append(math.sqrt(i))
    return result

def main():
    size = 10000
    for _ in range(size):
        result = computeSqrt(size)

main()
```



执行上述代码花费大约`34s`：

![](3-1.png)



## 第一次优化

对上边的代码进行优化，通过from import语句，可以消除属性访问。

```python
from math import sqrt

def computeSqrt(size: int):
    result = []
    for i in range(size):
        result.append(sqrt(i))  # 避免math.sqrt的使用
    return result

def main():
    size = 10000
    for _ in range(size):
        result = computeSqrt(size)

main()
```



优化后执行需要大约`31s`：

![](3-2.png)



## 第二次优化



再进行优化，局部变量的查找会比全局变量更快，因此对于频繁访问的变量sqrt，通过将其改为局部变量可以加速运行。

```python
import math

def computeSqrt(size: int):
    result = []
    sqrt = math.sqrt  # 赋值给局部变量
    for i in range(size):
        result.append(sqrt(i))  # 避免math.sqrt的使用
    return result

def main():
    size = 10000
    for _ in range(size):
        result = computeSqrt(size)

main()
```



优化后执行需要大约`30s`：

![](3-3.png)



## 第三次优化

还可以优化，除了`math.sqrt`外，`computeSqrt`函数中还有`.`的存在，那就是调用list的append方法。通过将该方法赋值给一个局部变量，可以彻底消除computeSqrt函数中for循环内部的`.`使用。

```python
import math

def computeSqrt(size: int):
    result = []
    append = result.append
    sqrt = math.sqrt    # 赋值给局部变量
    for i in range(size):
        append(sqrt(i))  # 避免 result.append 和 math.sqrt 的使用
    return result

def main():
    size = 10000
    for _ in range(size):
        result = computeSqrt(size)

main()
```



优化后执行需要大约`29s`：

![](3-4.png)



<br>



# 避免类内属性访问

访问`self._value`的速度会比访问一个局部变量更慢一些，例如：

```python
import math
from typing import List

class DemoClass:
    def __init__(self, value: int):
        self._value = value
    
    def computeSqrt(self, size: int) -> List[float]:
        result = []
        append = result.append
        sqrt = math.sqrt
        for _ in range(size):
            append(sqrt(self._value))
        return result

def main():
    size = 10000
    for _ in range(size):
        demo_instance = DemoClass(size)
        result = demo_instance.computeSqrt(size)

main()
```



执行上边的程序需要约`32s`

![](4-1.png)



通过将需要频繁访问的类内属性赋值给一个局部变量，可以提升代码运行速度。如：

```python
import math
from typing import List

class DemoClass:
    def __init__(self, value: int):
        self._value = value
    
    def computeSqrt(self, size: int) -> List[float]:
        result = []
        append = result.append
        sqrt = math.sqrt
        value = self._value
        for _ in range(size):
            append(sqrt(value))  # 避免 self._value 的使用
        return result

def main():
    size = 10000
    for _ in range(size):
        demo_instance = DemoClass(size)
        demo_instance.computeSqrt(size)

main()
```



优化后执行需要约`28s`

![](4-2.png)



<br>



# 避免不必要抽象

任何时候当你使用额外的处理层（比如装饰器、属性访问、描述器）去包装代码时，都会让代码变慢。如：

```python
class DemoClass:
    def __init__(self, value: int):
        self.value = value

    @property
    def value(self) -> int:
        return self._value

    @value.setter
    def value(self, x: int):
        self._value = x

def main():
    size = 1000000
    for i in range(size):
        demo_instance = DemoClass(size)
        value = demo_instance.value
        demo_instance.value = i

main()
```



执行需要约`1s`:

![](5-1.png)



重新进行审视使用属性访问器的定义是否有必要，如果真的没有必要，就使用简单属性。

```python
class DemoClass:
    def __init__(self, value: int):
        self.value = value  # 避免不必要的属性访问器

def main():
    size = 1000000
    for i in range(size):
        demo_instance = DemoClass(size)
        value = demo_instance.value
        demo_instance.value = i

main()
```



优化后执行约`0.4s`

![](5-2.png)



<br>



# 避免数据复制

有的代码会创建不必要的数据结构或复制，如：

```python
def main():
    size = 10000
    for _ in range(size):
        value = range(size)
        value_list = [x for x in value]
        square_list = [x * x for x in value_list]

main()
```

> 上面的代码中value_list完全没有必要



代码执行约`7s`

![](6-1.png)



优化后代码如下：

```python
def main():
    size = 10000
    for _ in range(size):
        value = range(size)
        square_list = [x * x for x in value]  # 避免无意义的复制

main()
```



优化后执行约`5s`

![](6-2.png)

<br>



# 值交换不使用中间变量

有的代码交换值时创建了一个临时变量temp，如：

```python
def main():
    size = 1000000
    for _ in range(size):
        a = 3
        b = 5
        temp = a
        a = b
        b = temp

main()
```



如果不借助中间变量，代码更为简洁、且运行速度更快:

```python
def main():
    size = 1000000
    for _ in range(size):
        a = 3
        b = 5
        a, b = b, a  # 不借助中间变量

main()
```



<br>



# 字符串拼接用join而不是+

当使用`a + b`拼接字符串时，由于 Python 中字符串是不可变对象，其会申请一块内存空间，将a和b分别复制到该新申请的内存空间中。因此，如果要拼接 n个字符串，会产生 n个中间结果，每产生一个中间结果都需要申请和复制一次内存，严重影响运行效率。如：

```python
import string
from typing import List

def concatString(string_list: List[str]) -> str:
    result = ''
    for str_i in string_list:
        result += str_i
    return result

def main():
    string_list = list(string.ascii_letters * 100)
    for _ in range(10000):
        result = concatString(string_list)

main()
```

代码运行大约`7s`：

![](7-1.png)



而使用`join()`拼接字符串时，会首先计算出需要申请的总的内存空间，然后一次性地申请所需内存，并将每个字符串元素复制到该内存中去。

```python
import string
from typing import List

def concatString(string_list: List[str]) -> str:
    return ''.join(string_list)  # 使用 join 而不是 +

def main():
    string_list = list(string.ascii_letters * 100)
    for _ in range(10000):
        result = concatString(string_list)

main()
```



优化后大约需要`0.3s`:

![](7-2.png)



<br>





# 利用if条件的短路特性

不使用短路特性时：

```python
from typing import List

def concatString(string_list: List[str]) -> str:
    abbreviations = {'cf.', 'e.g.', 'ex.', 'etc.', 'flg.', 'i.e.', 'Mr.', 'vs.'}
    abbr_count = 0
    result = ''
    for str_i in string_list:
        if str_i in abbreviations:
            result += str_i
    return result

def main():
    for _ in range(10000):
        string_list = ['Mr.', 'Hat', 'is', 'Chasing', 'the', 'black', 'cat', '.']
        result = concatString(string_list)

main()
```



if 条件的短路特性是指对`if a and b`这样的语句， 当a为False时将直接返回，不再计算b；

对于`if a or b`这样的语句，当a为True时将直接返回，不再计算b。因此， 为了节约运行时间，对于or语句，应该将值为True可能性比较高的变量写在or前，而and应该推后。

```python
from typing import List

def concatString(string_list: List[str]) -> str:
    abbreviations = {'cf.', 'e.g.', 'ex.', 'etc.', 'flg.', 'i.e.', 'Mr.', 'vs.'}
    abbr_count = 0
    result = ''
    for str_i in string_list:
        if str_i[-1] == '.' and str_i in abbreviations:  # 利用 if 条件的短路特性
            result += str_i
    return result

def main():
    for _ in range(10000):
        string_list = ['Mr.', 'Hat', 'is', 'Chasing', 'the', 'black', 'cat', '.']
        result = concatString(string_list)

main()
```

<br>



# 用for循环代替while循环

优化前：

```python
def computeSum(size: int) -> int:
    sum_ = 0
    i = 0
    while i < size:
        sum_ += i
        i += 1
    return sum_

def main():
    size = 10000
    for _ in range(size):
        sum_ = computeSum(size)

main()
```



Python 的for循环比while循环快不少。

```python
def computeSum(size: int) -> int:
    sum_ = 0
    for i in range(size):  # for 循环代替 while 循环
        sum_ += i
    return sum_

def main():
    size = 10000
    for _ in range(size):
        sum_ = computeSum(size)

main()
```

<br>



# 使用隐式for循环代替显式for循环

针对上面的例子，更进一步可以用隐式for循环来替代显式for循环

```python
def computeSum(size: int) -> int:
    return sum(range(size))  # 隐式 for 循环代替显式 for 循环

def main():
    size = 10000
    for _ in range(size):
        sum = computeSum(size)

main()
```

<br>



# 减少内层for循环的计算

```python
import math

def main():
    size = 10000
    sqrt = math.sqrt
    for x in range(size):
        for y in range(size):
            z = sqrt(x) + sqrt(y)

main()
```

上面的代码中sqrt(x)位于内侧for循环， 每次训练过程中都会重新计算一次，增加了时间开销。



```python
import math

def main():
    size = 10000
    sqrt = math.sqrt
    for x in range(size):
        sqrt_x = sqrt(x)  # 减少内层 for 循环的计算
        for y in range(size):
            z = sqrt_x + sqrt(y)

main()
```

<br>



# 使用numba.jit

我们沿用上面介绍过的例子，在此基础上使用numba.jit。numba可以将 Python 函数 JIT 编译为机器码执行，大大提高代码运行速度。

http://numba.pydata.org/numba.pydata.org

```python
import numba

@numba.jit
def computeSum(size: float) -> int:
    sum = 0
    for i in range(size):
        sum += i
    return sum

def main():
    size = 10000
    for _ in range(size):
        sum = computeSum(size)

main()
```

<br>

