---
title: 迭代器和生成器
date: 2020-08-11 11:02:30
tags: 
- Python
categories:
- Python
description: python中的迭代器和生成器
cover: https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1597125120623&di=dfb59bbfb4e4acd0b5807f10b40a9a42&imgtype=0&src=http%3A%2F%2Fimage.uczzd.cn%2F1327657598994857882.jpeg%3Fid%3D0%26from%3Dexport
---



# 迭代器

迭代器是一个可以记住遍历的位置的对象，是访问集合元素的一种方式。



迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退，有两个基本的方法：`iter()`和 `next()`。

> 字符串，列表或元组对象都可用于创建迭代器：



例如，将一个列表生成为迭代器并访问其中的元素：

```python
>>> list=[1,2,3,4]
>>> it = iter(list)    # 创建迭代器对象
>>> print (next(it))   # 输出迭代器的下一个元素
1
>>> print (next(it))
2
>>>
```



或者使用`for`循环遍历：

```python
list=[1,2,3,4]
it = iter(list)    # 创建迭代器对象
for x in it:
    print(x, end=" ")
```



当迭代器遍历结束会抛出`StopIteration`异常：

```python
import sys         # 引入 sys 模块
list=[1,2,3,4]
it = iter(list)    # 创建迭代器对象
while True:
    try:
        print (next(it))
    except StopIteration:        
        sys.exit()
```



<br>



# 创建迭代器

把一个类作为一个迭代器使用需要在类中实现两个方法`__iter__()`与`__next__()`。

- `__iter__()`方法返回一个特殊的迭代器对象， 这个迭代器对象实现了`__next__()`方法并通过 `StopIteration` 异常标识迭代的完成；
- `__next__()`方法会返回下一个迭代器对象；



例如创建一个返回数字的迭代器，初始值为 1，逐步递增 1，迭代5次停止：

```python
class MyNumbers:  
  def __iter__(self):    
    self.a = 1
    return self
  def __next__(self):    
    if self.a <= 5:      
      x = self.a
      self.a += 1
      return x
    else:      
      raiseStopIteration
myclass = MyNumbers()
myiter = iter(myclass)
for x in myiter:  
  print(x)

# 输出结果为 1 2 3 4 5
```



<br>





# 生成器

python中生成器是Generator，它是可以生成值的函数。当一个函数中存在了 **yield** 关键字的时候它就成为了一个生成器函数。生成器函数可以挂起执行并保持当前的执行状态。



例如下面的函数：

```python
def simple_gen():
  yield 'hello'
  yield 'world'
```



这个函数就是一个生成器函数，这个函数第一次产出 `hello`，第二次产出```world```，函数的使用如下：

```python
# 创建生成器对象，输出为：<class 'generator'>
gen = simple_gen()
print(type(gen))

# 获取第一个值，输出hello
print(next(gen))

# 获取第二个值，输出world
print(next(gen))
```



生成器是一个返回迭代器的函数，只能用于迭代操作。例如下面生成斐波那锲数列的生成器返回一个斐波那锲数列的迭代器进行迭代：

```python
import sys
def fibonacci(n): # 生成器函数 - 斐波那契
    a, b, counter = 0, 1, 0
    while True:
        if (counter > n): 
            return
        yield a
        a, b = b, a + b
        counter += 1
f = fibonacci(10) # f 是一个迭代器，由生成器返回生成，输出10位
while True:
    try:
        print (next(f), end=" ")
    except StopIteration:
        sys.exit()
        
# 输出结果：0 1 1 2 3 5 8 13 21 34 55
```



<br>





# 基于生成器的协程

生成器可以通过`yield`暂停执行和产出数据，在pep32中，同时支持使用```send()```向生成器发送数据和使用```throw()```向生成器抛出异常。



例如，首先定义了一个生成器函数：

```python
def coro():
  hello = yield 'hello'   # yield关键字在等号右边作为表达式，可以被send值
  yield hello
```



然后获取生成器的值并send新的值：

```python
# 创建生成器对象，并获取生成器的值，输出为hello，输出后函数暂停
c = coro()
print(next(c))

# 使用send()向生成器传值，输出为world
print(c.send('world'))

# 之后协程结束，再send就会抛出StopIteration异常
```



使用协程需要注意的地方：

- 协程需要使用`send(None)`或`next(continue)`来预激(prime)才能启动；
- 在yield处会暂停；
- 单独的yield会产出值给调用方；

